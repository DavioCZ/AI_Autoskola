import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import fetch from "node-fetch";
import { spawn } from "child_process";
import fs from "node:fs/promises";
import path from "path";
import { fileURLToPath } from "url";
import { buildAnalysisIndex } from "./utils/buildAnalysisIndex.js";
import { GoogleGenerativeAI } from "@google/generative-ai";

dotenv.config();
let analysisIndex;
const { GEMINI_API_KEY }  = process.env;
const MODEL_CHAT          = "gemini-1.5-flash-latest"; // Changed to a valid, recent model

if (!GEMINI_API_KEY) { console.error("‚ùå  Chyb√≠ GEMINI_API_KEY v .env"); process.exit(1); }

const genAI   = new GoogleGenerativeAI(GEMINI_API_KEY);
// const vision model initialization is removed

// The SDK will handle the endpoint, so the manual URL is no longer needed.

const app = express();
app.use(cors());
app.use(express.json({ limit: "8mb" }));   // zv√Ω≈°eno kv≈Øli base64 m√©di√≠m

// --- Statick√© soubory pro produkci ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
app.use(express.static(path.join(__dirname, "dist")));

/* ---------- 1) klasick√© textov√© dotazy /api/ai -------------------------------- */
// The user's prompt mentioned "‚Ä¶ tv≈Øj p≈Øvodn√≠ prompt ‚Ä¶" and "nech√°v√°m tvou posledn√≠ logiku"
// I will assume the /api/ai endpoint should remain as it was if there was prior logic.
// For now, I'll keep it minimal as per the provided snippet.
// If you have existing logic for /api/ai, it should be preserved here.
const SYSTEM_PROMPT_CHAT = `
Jsi AI lektor v auto≈°kole. Tv√° hlavn√≠ role je pom√°hat student≈Øm pochopit dopravn√≠ p≈ôedpisy a situace.
Komunikuj p≈ô√°telsky, trpƒõlivƒõ a povzbudivƒõ.
Pou≈æ√≠vej jednoduch√Ω jazyk, vyh√Ωbej se p≈ô√≠li≈°n√©mu formalismu, pokud to nen√≠ nutn√© pro citaci z√°kona.
Tv√Ωm c√≠lem nen√≠ jen sdƒõlit spr√°vnou odpovƒõƒè, ale v√©st studenta k pochopen√≠.

Kl√≠ƒçov√© pokyny pro interakci:
‚óè Pokud je re≈æim COACH, nikdy neprozrazuj spr√°vnou odpovƒõƒè,
  dokud student s√°m nevybere mo≈ænost nebo si v√Ωslovnƒõ ne≈ôekne.
‚óè V re≈æimu COACH klad‚Äô nav√°dƒõc√≠ ot√°zky a p≈ôipome≈à relevantn√≠ pravidla (citace z√°kona, principy).
‚óè V re≈æimu FEEDBACK:
    ‚Äì nejprve zhodno≈• zvolenou odpovƒõƒè (spr√°vn√° / chybn√°),
    ‚Äì pak vysvƒõtli proƒç, struƒçnƒõ vypi≈° d≈Øvody ostatn√≠ch mo≈ænost√≠.
‚óè Buƒè struƒçn√Ω a k vƒõci, ale dostateƒçnƒõ vysvƒõtluj√≠c√≠.
‚óè Pokud student polo≈æ√≠ ot√°zku nesouvisej√≠c√≠ s auto≈°kolou, zdvo≈ôile odm√≠tni a vra≈• se k t√©matu.
‚óè Pou≈æ√≠vej markdown pro form√°tov√°n√≠ textu (nap≈ô. tuƒçn√© p√≠smo pro d≈Øle≈æit√© term√≠ny, odr√°≈æky pro v√Ωƒçty).
`.trim();

app.post("/api/ai", async (req, res) => {
  try {
    const { userQuestion, context, history } = req.body;

    if (!analysisIndex) {
      // This should not happen if the server started correctly, but it's a good fallback.
      console.warn("‚ö†Ô∏è Analysis index not ready, building dynamically...");
      analysisIndex = await buildAnalysisIndex();
      console.log(`‚úÖ Dynamic index built, ${analysisIndex.size} items loaded.`);
    }

    const questionId = context?.question?.id_otazky;
    if (!questionId) {
      return res.status(400).json({ error: "Question ID is missing in the context." });
    }

    const analysis = analysisIndex.get(questionId);

    if (!userQuestion) {
      return res.status(400).json({ error: "User question is required for /api/ai" });
    }
    if (!context || typeof context.question === 'undefined') {
      return res.status(400).json({ error: "Context with question is required for /api/ai" });
    }

    let revealFlag = false;
    if (context.studentSelected !== null && typeof context.studentSelected !== 'undefined') {
      revealFlag = true;
    }
    if (context.explicitlyAsked === true) {
      revealFlag = true;
    }

    const analysisPromptPart = analysis
      ? `
## Detailn√≠ anal√Ωza k ot√°zce
Shrnut√≠: ${analysis.shrnuti}
Relevantn√≠ poznatky:
- ${analysis.poznatky_relevantni_k_odpovedim.join("\n- ")}
`
      : `
## Detailn√≠ anal√Ωza k ot√°zce
(Pro tuto ot√°zku nen√≠ k dispozici ≈æ√°dn√° p≈ôedem p≈ôipraven√° anal√Ωza. Odpovƒõz na z√°kladƒõ kontextu ot√°zky.)
`;

    const dynamicPrompt = `
${SYSTEM_PROMPT_CHAT}

## Kontext ot√°zky
${JSON.stringify(context.question, null, 2)}
${analysisPromptPart}
## Pokyny pro lektora
Re≈æim: ${revealFlag ? "FEEDBACK" : "COACH"}
- COACH: nevyslovuj spr√°vnou odpovƒõƒè; polo≈æ 2 ‚Äì 3 nav√°dƒõc√≠ ot√°zky a p≈ôipome≈à principy.
- FEEDBACK: vyhodno≈• zvolenou mo≈ænost, vysvƒõtli proƒç je (ne)spr√°vn√° a proƒç ostatn√≠ mo≈ænosti neplat√≠.

## Aktu√°ln√≠ replika studenta
${userQuestion}
`.trim();

    // Using the official Google Generative AI SDK
    const model = genAI.getGenerativeModel({ model: MODEL_CHAT });
    const result = await model.generateContent(dynamicPrompt);
    const response = await result.response;
    const answer = response.text();

    res.json({ answer });

  } catch (e) {
    console.error("Error in /api/ai:", e);
    res.status(500).json({ error: e.message });
  }
});

/* ---------- 2) endpoint pro z√≠sk√°n√≠ kontextu z obr√°zku /api/image-context --- */
app.post("/api/image-context", (req, res) => {
  const { question_id, url } = req.body;

  if (!question_id && !url) {
    return res.status(400).json({ error: "Je nutn√© poskytnout 'question_id' nebo 'url'." });
  }

  const args = ["py_scripts/image_context_cli.py"];
  if (question_id) {
    args.push("--question-id", question_id);
  }
  if (url) {
    args.push("--url", url);
  }
  
  // Cesta k adres√°≈ô≈Øm s anal√Ωzami
  const analyza_okruh1 = "public/analyza_okruh1";
  args.push("--json-path", analyza_okruh1);
  // Zde m≈Ø≈æete p≈ôidat dal≈°√≠ cesty, nap≈ô.
  // const analyza_okruh2 = "public/analyza_okruh2";
  // args.push("--json-path", analyza_okruh2);


  const pythonProcess = spawn("python", args);

  let dataToSend = "";
  pythonProcess.stdout.on("data", (data) => {
    dataToSend += data.toString();
  });

  let errorToSend = "";
  pythonProcess.stderr.on("data", (data) => {
    errorToSend += data.toString();
  });

  pythonProcess.on("close", (code) => {
    if (code !== 0) {
      console.error(`Python script exited with code ${code}`);
      console.error("Chyba z Python skriptu:", errorToSend);
      return res.status(500).json({ error: "Chyba p≈ôi zpracov√°n√≠ v Pythonu.", details: errorToSend });
    }
    try {
      const jsonData = JSON.parse(dataToSend);
      res.json(jsonData);
    } catch (e) {
      console.error("Chyba p≈ôi parsov√°n√≠ JSON z Pythonu:", e);
      console.error("Data z Pythonu:", dataToSend);
      res.status(500).json({ error: "Nepoda≈ôilo se zpracovat odpovƒõƒè z Python skriptu." });
    }
  });
});

const ANALYSIS_FILE_PATH = "data/analysis-data.json";

app.post("/api/save-analysis", async (req, res) => {
  // console.log("[/api/save-analysis] Received request.");
  const { entries } = req.body;
  // console.log("[/api/save-analysis] Entries received:", JSON.stringify(entries, null, 2));

  if (!entries || !Array.isArray(entries) || entries.length === 0) {
    return res.status(400).json({ error: "No analysis entries provided." });
  }

  try {
    // Zajistit, ≈æe adres√°≈ô existuje, ne≈æ se do nƒõj pokus√≠me zapsat
    await fs.mkdir(path.dirname(ANALYSIS_FILE_PATH), { recursive: true });

    let existingData = [];
    try {
      const fileContent = await fs.readFile(ANALYSIS_FILE_PATH, "utf8");
      existingData = JSON.parse(fileContent);
    } catch (error) {
      if (error.code !== 'ENOENT') { // ENOENT means file doesn't exist, which is fine
        throw error;
      }
    }

    const newData = [...existingData, ...entries];
    await fs.writeFile(ANALYSIS_FILE_PATH, JSON.stringify(newData, null, 2), "utf8");
    
    // console.log(`[/api/save-analysis] Successfully wrote ${entries.length} new entries.`);

    // // --- DIAGNOSTIC READ ---
    // try {
    //   const fileContentAfterWrite = await fs.readFile(ANALYSIS_FILE_PATH, "utf8");
    //   console.log("[DIAGNOSTIC] File content after write:", fileContentAfterWrite);
    // } catch (diagError) {
    //   console.error("[DIAGNOSTIC] Error reading file after write:", diagError);
    // }
    // // --- END DIAGNOSTIC ---

    res.status(200).json({ message: "Analysis data saved successfully." });
  } catch (e) {
    console.error("Error in /api/save-analysis:", e);
    res.status(500).json({ error: e.message });
  }
});

app.get("/api/analysis-data", async (req, res) => {
  try {
    const fileContent = await fs.readFile(ANALYSIS_FILE_PATH, "utf8");
    res.json(JSON.parse(fileContent));
  } catch (error) {
    if (error.code === 'ENOENT') {
      return res.json([]);
    }
    console.error("Error reading analysis data:", error);
    res.status(500).json({ error: "Failed to read analysis data" });
  }
});

app.post("/api/reset-analysis", async (req, res) => {
  try {
    await fs.unlink(ANALYSIS_FILE_PATH);
    res.status(200).json({ message: "Analysis data reset successfully." });
  } catch (error) {
    if (error.code === 'ENOENT') {
      // Soubor neexistuje, co≈æ je v po≈ô√°dku
      return res.status(200).json({ message: "Analysis data was already empty." });
    }
    console.error("Error in /api/reset-analysis:", error);
    res.status(500).json({ error: error.message });
  }
});


// Vision API and downloadAndEncode helper are removed.

/**
 * Loads the analysis index from the static JSON file.
 * Falls back to building it dynamically if the file doesn't exist.
 */
async function loadAnalysisIndex() {
  try {
    console.log("üõ†Ô∏è  Loading static analysis index from public/analysisIndex.json...");
    const jsonContent = await fs.readFile("public/analysisIndex.json", "utf8");
    const jsonObject = JSON.parse(jsonContent);
    analysisIndex = new Map(Object.entries(jsonObject));
    console.log(`‚úÖ Index loaded, ${analysisIndex.size} items ready.`);
  } catch (error) {
    console.error("‚ùå Failed to load static analysis index.", error.message);
    console.log("‚ÑπÔ∏è Falling back to dynamic index building...");
    analysisIndex = await buildAnalysisIndex();
    console.log(`‚úÖ Dynamic index built, ${analysisIndex.size} items loaded.`);
  }
}

// Catch-all pro serv√≠rov√°n√≠ index.html (pro React Router)
app.get('*', (req, res) => {
  // Pokud po≈æadavek smƒõ≈ôuje na API, nechej ho propadnout (nebo zpracuj jinak)
  if (req.originalUrl.startsWith('/api/')) {
    return res.status(404).json({ error: 'API endpoint not found' });
  }
  // Jinak po≈°li hlavn√≠ soubor aplikace
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, async () => {
  await loadAnalysisIndex();
  console.log(`AI proxy bƒõ≈æ√≠ na :${PORT} (chat=${MODEL_CHAT})`);
});
